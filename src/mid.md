#微服务

##微服务设计
###API Gateway
##微服务治理
### 隔离
#### 概念
隔离本质是对系统活资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即当系统发生故障后只有出现问题的服务不可用，保证其他服务仍然可用
####隔离分类
服务隔离

• 动静分离、读写分离

轻重隔离

• 核心、快慢、热点

物理隔离

• 线程、进程、集群、 机房
##### 服务隔离
###### 动静隔离
思路：
加速或者缓存变换频次比较小的
目的：
1.降低应用服务器的负载
2.对象存储费用最低，可以租赁一台服务器然后全部资源文件扔上去
3.海量存储空间，无需考虑存储架构的升级
4.静态CDN带宽加速，延迟低
##### 轻重隔离
读写分离
主从、Replicast、CQRS
方案：加速表
比如i8要统计A项目下所有的发票数量。常规链路可能就是 项目 查 合同 count(*)发票--count,sum容易把数据库搞崩。
这样链路就要经过合同服务和发票服务。
如果我们建一张加速表（用于统计项目的发票信息），去订阅发票吧表的变化然后更新这个加速表的计数，那么
我们就不需要走下游的合同服务和发票服务也可以拿到统计后的数据
###### 核心隔离
按业务轻重划分，业务重的资源多给少的少给
###### 快慢隔离

##### 物理隔离

### 超时控制
### 过载保护
### 限流
### 降级
### 重试
####幂等

### 负载均衡
##分布式缓存
###缓存选型
####Memcache
Memcache提供简单的KV Cache存储
value大小不超过1M
可以使用Memcache做大文本或者简单的KV结构

####Redis
##### 数据类型
###### string（SDS）
和C,golang比较
1.直接维持了字符串的长度
2.预分配，减少了字符串的长度
例如Monkey，他除了分配给你Monkey的长度外还会额外分配给你一段free
预分配会带来额外的内存开销，但是大多数情况不会变成一个问题
分配规则 2的米
###### hash table
go Map 实现
####### hash冲突
要知道hash冲突产生的原因\
最通俗的话说Map是一种通过key来获取value的一个数据结构，其底层存储方式为数组，
在存储时key不能重复，当key重复时，value进行覆盖，我们通过key进行hash运算
（可以简单理解为把key转化为一个整形数字）然后对数组的长度取余，
得到key存储在数组的哪个下标位置，最后将key和value组装为一个结构体，放入数组下标处；\
那么如果有2个key，hash之后得到的key是相同的那么要如何解决?\
两种办法\
1.开放定址（线性探测）\
也就是说当我们存储一个key，value时，发现hashkey(key)的下标已经被别key占用，那我们在这个数组中空间中重新找一个没被占用的存储这个冲突的key
常见的有线性探测法，线性补偿探测法，随机探测法，这里我们主要说一下线性探测法

线性探测，字面意思就是按照顺序来，从冲突的下标处开始往后探测，到达数组末尾时，
从数组开始处探测，直到找到一个空位置存储这个key，
当数组都找不到的情况下回扩容（事实上当数组容量快满的时候就会扩容了）
；查找某一个key的时候，找到key对应的下标，比较key是否相等，
如果相等直接取出来，否则按照顺寻探测直到碰到一个空位置，
说明key不存在。

2.拉链法\
拉链法解决冲突：冲突节点放到头部\
拉链法：何为拉链，简单理解为链表，当key的hash冲突时，
何为拉链，简单理解为链表，我们在冲突位置的元素上形成一个链表，通过指针互连接，
当查找时，发现key冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空
####### 扩容
渐进式rehash扩容\
何为渐进式扩容， redis其实是维护了2张map 新表扩容的长度是2'n,当需要扩容时会在
操作到数据之后将数据复制到新的map上去，老表都迁移完后交换2张表

###### linklist
双向链表
###### skiplist
跳表\
什么是跳表\
为什么redis使用跳表，为什么不适用平衡二叉树，红黑树，b树，b+树\
我觉得一个跳表实现比二叉树简单，另外平衡树不支持范围查找或者说支持很差
，b树，红黑树对范围查找支持很差。\
mysql 为什么要用b+树 而不使用跳表？\
主要原因是要控制深度。\
跳表深度是不可控制的，但是B+树是可以控制深度的，他的分叉会很多。\
那么为什么要控制深度呢？\
因为mysql是基于磁盘的。深度越深磁盘IO就要多消耗\
但是redis是基于内存的，深度再深影响也不大。
###### intset
###### ziplist
ziplist 的内存是连续,形似数组，可以理解为元素大小不定的素组.
结构
• zlbytes：ziplist 使用字节数
• zltail：最后元素的偏移量
• zllen：元素个数
• entry：元素
• zlend：结束标记

entry ：
• previous_entry_length：前一个
entry 的长度，一个字节或者五个字
节
• encoding：数据类型和长度
• content：节点数据

连锁更新：
previous_entry_length记录的是前一个entry的长度，所以前一个更新了长度那么后面的业务接着更新

ziplist 适合小数据量的，因为ziplist 一旦扩容就要重新拷贝一个内存。
#####值对象
#####高可用
Redis 高可用有两种模式，Sentinel 和 Cluster\
Sentinel :本质是主从模式，与一般的主从模式不同（一般的是什么模式呢？一般的模式是主是由从选举出来的）主节点的选举不是从节点完成的，
而是通过Sentinel来监控整个集群模式，发起主从选举，因此本质上Redis Sentinel 由两个集群
一个是Redis 数据集群，一个是哨兵Sentinel集群\
Cluster 集成了对等模式和主从模式（什么是对等模式，可以理解为所有节点都是平等的，例如kafka 的broken我们知道一个kafka集群由多个broken组成，这些broken都是平等的没有主从的关系）
Cluster由多个节点组成，每个节点都可以是一个主从集群（因为每个节点都是由Sentinel组成）。redis将key映射到slot（槽）
均匀分配在所有节点上
####### Sentinel 监控
三个步骤：主观下线->客观下线->主节点故障转移\
1、首先Sentinel获取主从结构的信息，而后向所有的节点发送心跳检测，如果整个时候
某个节点没有回复，就把他标记为主观下线\
2、如果整个节点是主节点，那么Sentinel就会问其他的Sentinel节点的主节点信息
如果大多数的Sentinel都认为主节点已经下线了，旧人物主节点已经客观下线。\
3、当主节点已经客观下线，就要步入故障转移阶段，分为两步骤，Sentinel要选举一个
leader,另一个整个Sentinel leader挑一个主节点
###### Redis Cluster
Redis Cluster 会把16384槽按照节点数量平均分配，由节点进行管理。
每个key都会按照CRC16规则进行Hash运算然后 hash 和1648取余然后把余数发送给Redis的节点\
为什么不直接把取余直接命中Redis节点而是先命中槽?\
最主要的原因是数据迁移。
如果我的redis多加了一个节点，那只需要其他节点贡献出一点槽就可以了。
##### 淘汰策略
1. volatile-lru
   淘汰对被设置过期时间最久未被使用的
2. volatile-lfu
   淘汰对被设置过期时间的可以最近访问频率最低的
3. volatile-random
   淘汰对被设置过期时间随机一个节点
4. allkeys-lru
   淘汰针对所有节点最久未被使用的
5. allkeys-lfu
   淘汰针对所有节点访问频率最低的
6. allkeys-random
   淘汰针对所有节点随机节点
7. ttl
   淘汰快要过期的
8. noeviction
   默认设置，不淘汰，内存满了抛异常
### 缓存一致性

##分布式事务